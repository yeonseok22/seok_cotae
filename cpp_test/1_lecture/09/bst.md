- 이진 탐색 트리
	1. 이진 탐색 트리
		- 이진 탐색 트리 (BST : binary search tree)
			- 효율적인 자료의 탐색을 위한 이진 트리 기반의 자료 구조
				- 자료의 계층적인 구조를 표현하기 위해 트리를 사용하는 것이 아니라. 자료의 효율적인 관리를 위해 트리 구조를 사용
			- **모든 노드 N에 대해, 왼쪽 서브트리에 있는 모든 노드의 키(key) 값은 노드 N의 키 값보다 작고, 오른쪽 서브트리에 있는 모든 노드의 키 값은 노드 N의 키 값보다 크다.**

		- 이진 탐색 트리의 특징
			- 자료의 **탐색**, **삽입**, **삭제**가 모두 O(log n) 시간 복잡도로 동작
			- 이진 탐색 트리를 중위순회하면 오름차순으로 정렬된 값을 얻을 수 있다.

			```
					 9
				4		 15
			 2	  6			18
				5
			```

			- 중위 순회 : 2 -> 4 -> 5 -> 6 -> 9 -> 15 -> 18
		
		- 이진 탐색 트리에서 삭제
			- 이진 탐색 트리에서 자료의 삭제는 해당 노드를 삭제한 후, BST 속성을 만족할 수 있는 다른 적절한 노드를 찾아 해당 노드로 대체해야 한다.
				- case 1 : 자식 노드가 없는 경우
					- 해당 노드를 삭제하고 링크를 제거
				- case 2 : 자식 노드가 하나만 있는 경우
					 - 해당 노드를 삭제하고, 부모 노드의 포인터가 해당 노드의 자식 노드를 가리키도록 설정
				- case 3 : 자식 노드가 두 개만 있는 경우
					- 후속 노드의 값을 현재 노드로 복사하고, 후속 노드를 삭제

				- 후속 노드(successor)
					- 현재 노드 다음으로 큰 값을 갖는 노드 
					- 현재 노드의 오른쪽 서브 트리에서 가장 작은 값의 노드
					- 후속 노드는 자식이 없거나 또는 오른쪽 자식만 있음

		- 이진 탐색 트리의 문제점
			- 원소의 삽입 순서에 따라 이진 탐색 트리가 한쪽으로 치우친 형태로 구성될 수 있음
			- 트리가 한쪽으로 치우칠 경우, 트리의 높이가 ```h = n - 1``` 형태로 구성되므로, 탐색, 삽입, 삭제 연산의 시간 복잡도가 O(n)으로 결정됨

			- 예제 1 : [5 -> 3 -> 7 -> 2 -> 4 -> 9 순서로 입력]
				```
						5
					3		7
				  2  4		  9
				```

			- 예제 2 : [2 -> 3 -> 4 -> 5 -> 7 -> 9 순서로 입력]
				```
				2
				  3
				    4
					  5
					    7
						  9
				```

		- 이진 탐색 트리의 문제점 해결 방법
			- 한쪽으로 치우친 트리의 구성을 변경하여 균형 잡힌 트리 형태로 변경할 수 있음

			- before
				
				```
						7
					5		9
				  3   6
				2  4
				```

			- after (트리 회전)
				
				```
						5
					3		7
				  2  4	   6  9
				```

			- 균형 잡힌 트리 예시 : AVL 트리, 레드-블랙 트리(red-black tree), B 트리, 스플레이 트리(splay tree) 등
					

	2. ```std::set```과 ```std::map```
		- C++ STL 컨테이너
			- 순차 컨테이너 (sequence containers)
				- vector
				- array
				- deque
				- list
				- forward_list
			- 연관 컨테이너 (associative acontainers)
				- set
				- multiset
				- map
				- multimap
			- 순서 없는 연관 컨테이너 (unordered associative containers)
				- unordered_set
				- unordered_multiset
				- unordered_map
				- unordered_multimap
			- 컨테이너 어댑터 (container adaptors)
				- stack
				- queue
				- priority_queue

		- 연관 컨테이너, 순서없는 연관 컨테이너
			- set과 map 차이
				- set은 키(key)만 저장
				- map은 키(key)와 값(value)을 저장

			- set와 multiset 차이
				- set은 고유한 키의 데이터만 저장 (중복 허용 안함)
				- multiset은 중복되는 데이터를 저장

			- set과 unordered_set 차이
				- set은 내부에서 데이터를 정렬해서 저장
				- unordered_set은 데이터를 정렬하지 않음

		- ```std::set``` 컨테이너
			```
			template<class Key,
					Class Compare = std::less<Key>,
					Class Allocator = std::allocator<Key>>
			class set;
			```

			- Key 타입의 키(key) 값을 저장하는 연관 컨테이너
			- 저장된 데이터는 키 값을 기준으로 정렬됨
			- 데이터 삽입, 삭제, 탐색은 O(log n) 시간 복잡도로 동작
			- ```std::set```은 보통 레드-블랙 트리(red-black tree)를 이용하여 구현됨
			- 만약, 중복되는 데이터를 set 구조로 저장하려면 ```std::multiset``` 컨테이너를 사용
			- 만약 데이터를 정렬하지 않은 상태로 저장하려면 ```std::unordered_set``` 컨테이너를 사용
			- 사용자 정의 타입을 저장할 경우, **비교 연산**을 지원해야 한다.
			- ```<set>```에 정의되어 있다.

		- ```std::set``` 주요 멤버 함수와 설명
			
			|멤버 함수 | 설명|
			|:----|:----|
			|```begin()```, ```end()```, ```rbegin()```, ```rend()```|순방향 및 역방향 반복자 반환|
			|```insert()```|(중복되지 않는) 새로운 원소를 삽입 (cf) ```emplace()```|
			|```erase()```|특정 원소를 삭제|
			|```find()```|특정 키 값을 갖는 원소를 찾아 반복자를 반환. 원소를 끝까지 찾지 못하면 ```end()```에 해당하는 반복자를 반환. (cf) ```contains()```|
			|```clear()```|모든 원소를 삭제|
			|```size()```|원소의 개수를 반환|
			|```empty()```|set이 비어 있으면 true를 반환|


		- ```std::map``` 컨테이너
			
			```C++
		    template<class Key, class T,
		             class Compare = std::less<Key>,
					 class Allocator = std::allocator<std::pair<const Key, T>>>
			class map;
			```

			- Key 타입의 키(key)와 T 타입의 값(value)의 쌍(pair)을 저장하는 연관 컨테이너
			- 저장된 데이터는 키 값을 기준으로 정렬됨
			- 데이터 삽입, 삭제, 탐색은 O(log n) 시간 복잡도로 동작
			- ```std::map```은 보통 레드-블랙 트리(red-black tree)를 이용하여 구현됨
			- 만약 중복되는 데이터를 map 구조로 저장하려면 ```std::multimap``` 컨테이너를 사용
			- 만약 데이터를 정렬되지 않은 상태로 저장하려면 ```std::unordered_map``` 컨테이너를 사용
			- 사용자 정의 타입을 저장할 경우, **비교 연산**을 지원해야 함
			- ```<map>```에 저장되어 있음

		- ```std::map``` 주요 멤버 함수와 설명
			
			|멤버 함수|설명|
			|:---|:---|
			|```begin()```, ```end()```, ```rbegin()```, ```rend()```|순방향 및 역방향 반복자 반환|
			|```insert()```|(중복되지 않는) 새로운 원소를 삽입 (cf) ```emplace()```|
			|```erase()```|특정 원소를 삭제|
			|```operator []```|특정 키에 해당하는 원소의 값을 참조로 반환. 해당 키의 원소가 없으면 새로운 원소를 기본갑으로 생성하여 참조를 반환. (cf) ```at()```|
			|```find()```|특정 키 값을 갖는 원소를 찾아 반복자를 반환. (cf) ```contains()```|
			|```clear()```|모든 원소를 삭제|
			|```size()```|원소의 개수를 반환|
			|```empty()```|map이 비어 있으면 true를 반환|


