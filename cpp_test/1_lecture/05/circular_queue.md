- 배열을 이용한 큐의 구현
	- 큐에 데이터의 삽입과 삭제가 지속적으로 발생할 경우, 배열의 앞 부분에 무효화되는 공간이 늘어난다.

- 환형 큐(Circular queue)
	- FIFO 원칙에 따라 작업이 수행되고, 마지막 위치가 마치 원을 이루듯이 다시 첫번째로 연결되는 선형 데이터 구조.
	- 원형 큐 형태

	- 큐의 front와 rear 값이 시계 방향으로 한 칸씩 이동하는 형태
		- 실제 구현에서는 배열 전체 크기를 이용하여 나머지(%) 연산을 수행

	- 큐가 empty 또는 full 상태인지를 확인하기 위해 원소의 개수를 따로 저장해야 함.


- 양방향 큐와 ```std::deque```
	- 양방향 큐(deque) : Double Ended QUeue
		- 삽입과 삭제가 양 쪽 끝에서 모두 가능한 자료 구조

	- 양방향 큐의 주요 연산
		- ```push_front(e)``` : 양방향 큐의 맨 앞에 원소 e를 추가
		- ```pop_front()``` : 양방향 큐의 맨 앞에 있는 원소를 삭제
		- ```push_back(e)``` : 양방향 큐의 맨 뒤에 원소 e를 추가
		- ```pop_back()``` : 양방향 큐의 맨 뒤에 있는 원소를 삭제
		- ```front()``` : 양방향 큐의 맨 앞에 있는 원소를 참조
		- ```back()``` : 양방향 큐의 맨 뒤에 있는 원소를 참조
		- ```empty()``` : 양방향 큐가 비어 있으면 true를 반환
		- ```size()``` : 양방향 큐의 원소 개수를 반환

	- 양방향 큐의 구현
		- 배열을 이용한 양방향 큐의 구현
			- 환형 큐와 비슷한 형식으로, 양방향 큐의 맨 앞과 맨 마지막 위치를 갱신
		- 연결 리스트를 이용한 양방향 큐의 구현
			- 이중 연결 리스트를 이용하여 연결 리스트의 맨 앞과 맨 뒤에 자료를 각각 추가 및 삭제 가능

	- ```std::deque```

		```
		template<class T, class Allocator = std::allocator<T>>
		class deque;
		```
		
		- 양 방향 큐의 동작을 지원하는 순차 컨테이너
		- ```<deque>```에 정의되어 있음
		- ```std::deque```의 특징
			- 원소에 대해 임의 접근 동작이 O(1) 시간 복잡도로 동작
			- 맨 앞과 맨 뒤에 자료를 추가 또는 삭제하는 연산이 O(1) 시간 복잡도로 동작
			- 중간 위치에서 자료를 삽입 또는 삭제는 O(n) 시간 복잡도로 동작 (n은 원소 개수)
			- ```std::stack```, ```std::queue``` 등의 STL 컨테이너 어댑터의 기본 컨테이너로 사용

	- ```std::deque```의 구현 방식
		- C++ 표준은 어떤 기능의 동작만을 정의할 분이며, 어떻게 구현해야 하는지는 정의하지 않음
		- 보통 ```std::deque```은 단일 메모리 청크(chunk)를 사용하지 않으며, 대신 크기가 같은 여러 개의 메모리 청크를 사용하여 데이터를 저장한다.

