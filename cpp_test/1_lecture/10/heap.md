# 힙과 우선순위 큐

## 1. 힙(heap)
- 힙(heap)
	- heap : 더미, 무더기, 퇴적물, (무엇인가를 차곡차곡) 쌓아올리다.
	- 자료 구조와 힙은 **완전 이진 트리**의 한 형태로서 **힙 속성**을 만족하는 자료 구조. 이진 힙(binary heap)
	- **힙 속성(heap property)**
		- **최대 힙 속성(max heap property)** : 부모 노드의 키 값은 항상 자식 노드의 키 값보다 크거나 같다.
			```C++
						15
					8		14
				7	  4	   9  10
			   5 2   4
			```
		- **최소 힙 속성(min heap property)** : 부모 노드의 키 값은 항상 자식 노드의 키 값보다 작거나 같다.
			```C++
						3
					5		9
				  10 7    15 14
			```

	- 힙의 특징
		- 루트 노드는 항상 **최댓값** 또는 **최솟값**을 갖음
		- 부모-자식 사이의 크기 관계만 있고, 왼쪽 자식-오른쪽 자식 사이의 크기 관계는 없음
		- 완전 이진 트리이기 때문에 트리의 높이는 h = [log_2 n]
		- 힙의 응용 분야 : 힙 정렬, 우선순위 큐, 다익스트라 알고리즘(Dijkstra's algorithm) 등

	- 힙 연산의 시간 복잡도
		- 최댓값 또는 최솟값 참조 : O(1)
		- 원소 삽입 : O(log N)
		- 원소 삭제 : O(log N)

	- 힙과 이진 탐색 트리(자료 확인)
	
		||힙|이진 탐색 트리|
		|:---:|:---:|:---:|
		|트리의 형태|완전 이진 트리|이진 트리|
		|원소 중복 여부|중복 가능|중복되지 않음|
		|원소의 정렬 여부|정렬되지 않음|정렬됨 (중위 탐색)|
		|빠른 원소 탐색|미지원 (순차 탐색, O(n))|지원 (이진 탐색, O(log N))|
		|원소의 삽입 또는 삭제|O(log N)|O(log N) / O(n)|
		|최댓값/최솟값 참조|O(1)|O(log N) / O(n)|

	- 힙 구현하기
		- 힙은 완전 이진 트리이므로 각 노드에 인덱스(index)를 붙이고, **배열**을 이용하여 쉽게 표현할 수 있음
		- 구현의 편의상 루트 노드의 인덱스를 1부터 시작 (배역 0번 인덱스는 무시)
		
		```C++
					15(1)				// L = 0
				8(2)		14(3)		// L = 1
			7(4)   4(5)	  9(6)  10(7)	// L = 2
		 5(8) 2(9)  3(10)				// L = 3
		```

		|0|1|2|3|4|5|6|7|8|9|10|
		|-|-|-|-|-|-|-|-|-|-|-|
		|-|15|8|14|7|4|9|10|5|2|3|

		- 루트 노드 인덱스 : 1
		- 인덱스가 m인 노드에 대해서
			- 부모 노드 인덱스 : m/2
			- 왼쪽 자식 인덱스 : m*2
			- 오른쪽 자식 인덱스 : m*2 + 1

	- 힙에 원소 삽입
		1. 힙의 맨 마지막에 새로운 원소 값을 갖는 노드를 추가한다.
		2. 새로 삽입한 노드와 부모 노드를 서로 비교하여 힙 속성을 만족하지 않으면 현재 노드와 부모 노드를 교환한다. 그리고 부모 노드에서 이 작업을 반복한다. (heapify_up)

	- 힙에서 원소 삭제
		1. 힙의 맨 마지막 노드 값을 루트 노드로 복사하고, 맨 마지막 노드를 삭제한다.
		2. 루트 노드와 두 자식 노드를 비교하여 힙 속성을 만족하지 않으면 두 자식 노드 중에서 더 큰(최대 힙) 노드와 서로 교환한다. 그리고 교환한 자식 노드에서 이 작업을 반복한다. (heapify_down)

## 2. 우선순위 큐와 ```std::priority_queue```
- 우선순위 큐(priority queue)
	- 각각의 데이터에 **우선순위(priority)**가 정의되어 있어서, 입력 순서에 상관없이 우선순위가 가장 높은 데이터가 먼저 출력되는 형태의 자료 구조
	- 우선순위의 예 : 응급 자동차, 네트워크 트래픽 우선 순위, 운영체제에서 프로그램 우선 순위
	- 일반 선입선출(FIFO) 큐 : 큐에 머무른 시간을 우선순위로 설정하면 일반 큐와 같이 동작

- 우선순위 큐 구현 방법

	|구현 방법|삽입|삭제|
	|:---:|:---:|:---:|
	|순서 없는 배열|O(1)|O(n)|
	|순서 없는 연결 리스트|O(1)|O(n)|
	|정렬된 배열|O(n)|O(1)|
	|정렬된 연결 리스트|O(n)|O(1)|
	|힙|O(log n)|O(log n)|

- C++에서 우선순위 큐 사용하기
	- STL에서 제공하는 ```std::priority_queue``` 컨테이너 사용

- ```std::priority_queue```
	```C++
    template <class T,
			  class Container = std::vector<T>,
			  class Compare = std::less<T>>
	class priority_queue;
	```
	- 우선순위 큐의 기능을 제공하는 컨테이너 어댑터
	- 삽입 순서에 상관 없이 우선순위가 가장 높은(기본적으로 값이 가장 큰) 원소가 먼저 출력됨
	- 사용자 정의 타입을 저장할 경우, **비교 연산**을 지원해야 한다.
	- ```<queue>```에 정의되어 있음
	- 주요 멤버 함수
		- ```priority_queue::push(e)``` : 우선순위 큐에 원소 e를 추가. O(log n)
		- ```priority_queue::pop()``` : 우선순위 큐의 최상위 원소를 제거. O(log n)
		- ```priority_queue::top()``` : 우선순위 큐의 최상위 원소를 참조. O(1)
